1. Line 12 will print 3 because var provides its variable with function scope so the variable i can be accessed on line 12 since it's inside the function and i is 3 since line 12 comes after the for loop above it which iterates i from 0 to 3.
2. Line 13 will print 150 because var provides discountedPrice with function scope and line 13 is inside the function so it can access discountedPrice which is 150 since the last time the loop updates the variable occurs when i = 2 so discountedPrice = prices[2] * (1 - 0.5) = 300 * (0.5) = 150.
3. Line 14 will print 150 because var provides finalPrice with function scope and line 14 is inside the function so it can access finalPrice which is 150 since the last time the loop updates finalPrice occurs when discountedPrice is 150 (see above) so finalPrice becomes Math.round(150 * 100)/100 = 150.
4. This function will return the array [50, 100, 150] because the for loop pushes finalPrice into the discounted array each time it runs (push adds the element to the back of the array). When var i = 0, discountedPrice = prices[0] * (1 - 0.5) = 100 * 0.5 = 50 so finalPrice = Math.round(50 * 100)/100 = 50 so 50 is pushed to discounted. When var i = 1, discountedPrice = prices[1] * (1 - 0.5) = 200 * 0.5 = 100 so finalPrice = Math.round(100 * 100)/100 = 100 so 100 is pushed to discounted. Lastly, when var i = 2, , discountedPrice = prices[2] * (1 - 0.5) = 300 * 0.5 = 150 so finalPrice = Math.round(150 * 100)/100 = 159 so 150 is pushed to discounted. Thus, after the loop is finished, discounted is [50, 100, 150] which gets returned.
5. The code causes an error because declaring the variable i with the let keyword provides i with block scope which means it can only be accessed within the for loop block it was defined in. Since line 12 is outside of that block, it can't access i so there's an error.
6. The code causes an error because declaring the variable discountedPrice with the let keyword provides it with block scope which means it can only be accessed within the for loop block it was defined in. Since line 13 is outside of that block, it can't access discountedPrice so there's an error.
7. Line 14 will print 150 because declaring the variable finalPrice with the let keyword provides it with block scope which means it can only be accessed within the block it was defined in which is the function in this case. Since line 14 is within the function, it can access finalPrice which is 150.
8. This function will return the array [50,100,150] because discounted was declared with the let keyword so it has block scope which means it can only be accessed within the block it was defined in which is the function in this case. Since line 16 is within the function, it can access discounted which is [50,100,150].
9. The code causes an error because declaring the variable i with the let keyword provides i with block scope which means it can only be accessed within the for loop block it was defined in. Since line 11 is outside of that block, it can't access i so there's an error.
10. Line 12 will print 3 because length was declared with the const keyword which provides it with block scope which is the function in this case and line 12 is within the function so it can access length.
11. This function will return the array [50,100,150] because discounted was declared with the const keyword which provides it with block scope which is the function in this case and line 14 is within the function so it can access discounted. discounted would be [50, 100, 150] after the for loop ends because when let i = 0, discountedPrice = prices[1] * (1 - 0.5) = 100 * 0.5 = 50 so 50 gets pushed to discounted. When let i = 1, discountedPrice = prices[1] * (1 - 0.5) = 200 * 0.5 = 100 so 100 gets pushed to discounted. Lastly, when let i = 2, discountedPrice = prices[2] * (1 - 0.5) = 300 * 0.5 = 150 so 150 gets pushed to discounted. Thus, after the loop is finished, discounted is [50,100,150] which gets returned.
12. A. student.name, B. student['Grad Year'], C. student.greeting(), D. student['Favorite Teacher'].name, E. student.courseLoad[0]
13. A. '32' because when you add a number to a string, the number is converted to an string and then concatenated, B. 1 because when you subtract an number from a string, the string is converted to a number and then numerically subtracted, C. 3 because when null is added to a number, it is converted to the number 0 then added to 3 and 3+0 = 3, D. '3null' because when null is added to a string, it is converted to a string then concatenated, E. 4 because when true is added with a number, it is converted to the number 1 then numerically added and 1+3 = 4, F. 0 because when null and false are added, they are both converted to the number 0 before being numerically added and 0+0 = 0, G. '3undefined' because when add undefined to a string, undefined is converted to a string then concatenated, H. NaN because when you subtract undefined from a string, both are converted to a number and then numerical subtraction happens, but undefined converts to Nan so you get 3 - Nan = Nan
14. A. True because the string '2' is converted to a number and 2 > 1 is true, B. False because the strings are compared character-by-character so first the '2' is compared to the '1' since they are the first characters in each string and '2' > '1' is false so that's the result, C. True because the string '2' is converted to a number and 2 == 2 is true, D. False because === checks the equality without type conversion and since 2 and '2' are different types you get false, E. False because true is converted to the number 1 and 1 isn't equal to 2, F. True because Boolean(2) = true since the Boolean of any value that's not 0, null, false, NaN, undefined, or empty is true and true === true.
15. == does type conversions if necessary before comparing for equality whereas === doesn't do type conversions before comparing.
17. The result will be [2,4,6]. When the function modifyArray is called with the parameters [1,2,3] and doSomething, the for loop runs 3 times since the length of the parameter array is 3. Each time, the doSomething function is run on the element in the i-th position of the parameter array and the resulting output is pushed to newArr. The doSomething function multiples the input by 2 so the first element 1, results in 2, the second element 2 results in 4, and the last element 3 results in 6. Thus, newArr becomes [2,4,6] and is returned.
19. 1 4 3 2 (each on separate lines) 
